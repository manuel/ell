Calling convention
==================

Functions are always called indirectly via a function pointer.

Global functions and closures use the same calling convention, and
closures are ordinary function pointers.

Every function gets its own address passed as an argument.  This is
used by closures to find their closed-over variables.

void *f_ptr(..., void *f_addr, ...)

Closure representation on the heap
==================================

+--------+
| c4     |
| c3     | 
| c2     | ... 
| c1     | -2    -- closure data (variable length)
| f_ptr  | -1    -- closure function pointer
| CODE   | 0     -- closure trampoline code
|        | ...
|        |
+--------+

A closure is represented as a heap-allocated object whose last member
is code that acts as a trampoline.

The trampoline uses the calling convention function address to find
the actual closure function and environment at negative offsets from
the address.

Closure environments
====================

Every lambda form results in a new closure, whose environment contains
bindings for the free variables that are closed over by the closure.

A free variable is a variable used in the body of a lambda that is
neither a global variable, nor a parameter of the lambda.

The environment of a closure is an array of pointers to the
closed-over values.  Inside the body of a closure, every closed-over
free variable is uniquely identified by its position in the
environment array, so variable lookups in a closure's environment are
fast.

A closure may also access a variable closed-over by one of the
closure's ancestors.  In this case, there is only one binding for the
variable shared by the ancestor and all descendants.

Generic function dispatch
=========================

For every generic function, a perfect hash function (PHF) is generated
that maps a class pointer (of every class that defines or inherits a
method for the generic function) to an index in an array of
first-class labels (with the method bodies).

Method lookups with this scheme should be very fast, as the PHF is
fast to compute, has no collisions, and invoking a method amounts to a
simple goto.

some_gen_fun(..., object *this, ...) {
  char phf_data[...];
  void **labels = [ &&label_1, &&label_2, ... ];
  goto labels[ phf(this->class, phf_data) ];
label_1:
  ... method impl ...
label_2:
  ... method impl ...
...
}

Dependent recompilation
=======================

The module dependency graph is kept in memory at runtime.

Object representation
=====================

Class representation
====================

Stack unwinding
===============

Macros
======

Modules
=======
