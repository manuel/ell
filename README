-*- outline -*-

* `ell': Executable and Linkable Lisp

** Goals

*** Deep integration with C ABIs, toolchain, and Unix
**** Inline C with easy calling back into Lisp
**** Do symbol lookups and variable refs at link-time
**** Produce stripped standalone binaries for distribution
**** Mix C and Lisp freely
**** Conservative GC

*** Convenient interactive environment
**** Automatic recompilation (incl. macro callers)
**** Dependency tracking
**** Everything's dynamically changeable
**** Files are user interface for tree-based "code database"

*** Robust compiletime metaprogramming
**** Syntax objects instead of conses (lexical scope info, line numbers, ...)
**** Deterministic compilation through strict phase separation
**** Automatic inference of phases where definitions are needed
**** Built-in unhygienic `defmacro' for language bootstrap
**** Hygienic macro system written in language on top of unhygienic

*** Performance comparable to fastest scripting languages
**** Compilation to native code via C compiler
**** Fast lexical lookup with De Bruijn indices

*** Principled, tractable implementation
**** Code database with hierarchical symbol namespace
**** Code nodes: variable, function, and macro definitions
**** Dependencies between nodes for runtime and compiletime
**** Files are committed to database, and broken down into nodes
**** Macros needed to expand a node run in a separate process
**** After macroexpansion, only kernel language forms remain
**** Dependencies are resolved lazily except for explicit requirements
**** The nodes in a file are automatically chained with explicit requirements
**** Database stores machine code of every node
**** For dynamic use at the REPL, lots of dynamic linking and loading
**** For distribution of static binary, produce prelinked shared object

*** As dynamic as Factor

*** High quality Lisp experience
**** Regular, reduced, extensible syntax
**** Restartable exceptions
**** Unwind protection
**** First-class nonlocal exits
**** Class redefinition
**** Optional, rest, and keyword parameters
**** Generalized references
**** Symbols with value cells
**** Per-thread dynamic scope
**** Lisp-2
**** Macros and quasiquotation
**** `eval'
**** Numerical tower
**** Deep object-orientation
**** Overridable, autogenerated constructor and slot accessor functions
**** Comfortable toplevel environment (defining != setting, etc)

*** High quality integration experience
**** Be faithful to Lisp (it's better), while embracing Unix
**** By rights, Lisp should own the internet

*** Orientation to programming language technology space
**** Building-block approach: integrate large tech pieces faithfully
**** Hygienic macro systems (Scheme)
**** Deterministic compilation through total phase separation (PLT Scheme)
**** Single inheritance + post-hoc mixins (Factor)
**** Lisp folklore core (Dylan, Common Lisp, ISLISP, EuLisp)
**** Inline C (Goo)
**** Code database (Fortress)
**** Examine delimited continuations

*** Track technology developments
**** Assume large caches and RAM, many cores, and lots of IOPS

*** Allow different concurrency models
**** Multi-thread support built-in
**** Biased towards event-driven programming
**** Robust use of dozens of C coroutine, protothreads, etc libs
