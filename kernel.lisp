;;;; Fundamental
(deftype <object>)
(deftype <function>)
(deftype <symbol>)
(deftype <string>)
(deftype <number>)
(deftype <boolean>)
(deftype <nil>)
(defconst #t)
(defconst #f)
(defconst nil)
(defmacro quote (symbol -> <symbol>))
(defun eq (<object> <object> -> <boolean>))
;;;; Bindings
(defmacro def (var-or-fun <object> -> <object>))
(defmacro set (var-or-fun <object> -> <object>))
(defun boundp (<symbol> -> <boolean>))
(defun fboundp (<symbol> -> <boolean>))
(defmacro function (fun-name -> <function>))
;;;; Functions
(defmacro lambda (sig form -> <function>))
(defun funcall (sym-or-fun args key-args -> <obj>))
(defun apply (sym-or-fun &rest &all-keys -> <obj>))
;;;; Control flow
(defmacro if (<bool> <form> <form> -> <obj>))
(defmacro progn (&body forms -> <obj>))
(defmacro unwind-protect (protected cleanup))
(defmacro block (label <form> -> <obj>))
(defmacro return-from (label &optional <obj>))
(defmacro tagbody (&body tagbody))
(defmacro go (tag))
;;;; Macros
(defmacro defmacro (name expander-fun))
(defmacro quasiquote (<form> -> <form>))
(defmacro unquote (<form>))
(defmacro unquote-splicing (<list-form>))
;;;; Classes
(deftype <type>)
(deftype <class> <: <type>)
(deftype <mixin> <: <type>)
(defun make-class (<symbol> -> <class>))
(defun set-slot-specs (<class> ...))
(defun set-superclass (<class> (superclass <class>)))
(defun make-mixin (<symbol> -> <mixin>))
(defun set-mixins (<type> (mixins <ordered-set>)))
(defun set-method (<type> <symbol> <function>))
(defun subtypep (<type> <type> -> <boolean>))
;;;; Objects
(defun make (symbol-or-class &all-keys slot-initializers))
(defun call-method (<obj> <sym> &rest &all-keys))
(defun slot-value (<obj> <sym> -> <obj>))
(defun set-slot-value (<obj> <sym> <obj>))
(defun class-of (<obj> -> <class>))
;;;; Exceptions
(defmacro handler-bind (handler-bindings &body forms -> <obj>))
(defun signal (condition -> <obj>))
;;;; Evaluation
(defun eval (<form> env -> <obj>))
;;;; Inline "C"
(defmacro native ((c-snippet <string>)))
