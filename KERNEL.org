* Kernel Language
** Bindings
*** defparameter name value -> name [special]
Defines a variable binding with the given name and value in the
current scope.
*** defun name function -> name [special]
Defines a function binding with the given name and function in the
current scope.
*** setq name value -> value [special]
Sets the global or local variable binding with the given name to the
given value.
*** fsetq name function -> function [special]
Sets the global or local function binding with the given name to the
given function.
*** boundp symbol -> boolean [function]
Returns true if there is a variable binding with the given name in the
current scope.
*** fboundp symbol -> boolean [function]
Returns true if there is a function binding with the given name in the
current scope.
** Functions
*** lambda signature form -> function [special]
Creates an anonymous function.
*** apply function (args <list>) (keys <dict>) -> result [function]
Applies a function to the given positional and keyword arguments.
*** funcall function &rest args &keys keys -> result [function]
Applies a function to the given positional and keyword arguments.
*** function name -> function [special]
Returns the function of the global or local function binding with the
given name.
*** values &rest objects -> object* [special]
Returns multiple values.  
*** multiple-value-call function &rest forms -> result [special]
Calls a function with multiple values.
** Control Flow
*** if test-form then-form else-form -> value [special]
If the test form evaluates to true, evaluates the then form, otherwise
evaluates the else form.
*** progn &rest exprs -> value [special]
Evaluates the expressions in sequence and returns value of the last.
*** call-with-escape-continuation function -> result [function]
Calls the given function with one argument, a function that represents
the current continuation.  Calling the continuation function with a
value will abort the current computation, and return the value from
the original call to CALL-WITH-ESCAPE-CONTINUATION.  An error is
signaled if the continuation is called more than once, or after the
dynamic extent of CALL-WITH-ESCAPE-CONTINUATION has ended.
*** unwind-protect protected-thunk cleanup-thunk -> result [function]
Calls the protected thunk and ensures that the cleanup thunk is called
whether the protected thunk returns normally, or via a non-local exit.
*** tagbody &body tagbody -> nil [special]
Creates a body of expressions and tags.  Expressions in the TAGBODY
may perform non-local jumps to tags with GO.
*** go tag -> | [special]
Performs a non-local jump to the given tag.
** Dynamic Variables
*** make-dynamic value -> dynamic [function]
Creates a new dynamic (thread-local) variable object.
*** dynamic dynamic -> value [function]
Returns the value of the dynamic variable.
*** set-dynamic dynamic value -> value [function]
Sets the value of the dynamic variables.
** Macros
*** defsyntax name expander-function -> name [special]
Defines an expander function with the given name in the current scope.
*** quasisyntax form -> form [special]
Constructs a piece of quoted syntax with unquotes.
*** datum->syntax template-id form -> form [function]
Repaints the form with the same color as the template identifier.
** Evaluation
*** eval form -> result [special]
Evaluates the form in the top-level environment and returns its value.
** Classes
*** make-class name superclasses slot-specifiers -> class [function]
Creates a new class with the given name, superclasses, and slot
specifiers.
*** set-superclasses class superclasses [function]
Updates the superclasses of the class.
*** put-method class method-name function [function]
Sets the method definition with the given name for the class.
*** set-slot-specifiers class slot-specifiers [function]
Updates the slot specifiers of the given class.  Instances are updated
lazily to the new layout.
*** subclassp a b -> boolean [function]
Returns true if class A is a subclass of class B.
** Objects
*** make-instance class &keys slots -> object [function]
Creates a new object of the given class, and initializes its slots
using the supplied dictionary.
*** find-method object method-name &rest &keys -> function [function]
Looks for the method with the given name in the object's class and
superclasses.
*** slot-value object slot-name -> value [function]
Returns the value of the named slot of the object.
*** set-slot-value object slot-name value -> value [function]
Sets the named slot of the object to the given value.
*** class-of object -> class [function]
Returns the class of the given object.
*** no-applicable-method object method-name args keys -> result [generic]
Called when no method with the given name exists in the object's class
or its superclasses.
** Packages
*** defpackage name &body -> nil [special]
Defines a new named scope, that can be separately compiled.  The body
of a package cannot access lexically enclosing variables.  The binding
for the package exists in the variable namespace, but cannot be changed.
*** provide &rest names -> nil [special]
Makes the bindings with the given names available to other packages.
For every name, both the variable and function binding is provided.
PROVIDE expressions must appear before any other forms in a package.
*** require package -> nil [special]
Loads the specified package if it isn't loaded yet, and makes its
top-level bindings accessible in the current scope.
*** require-for-syntax package -> nil [special]
Advises the compiler that bindings from the specified package may be
required for the compilation of the current package.  This is merely a
hint.  If actually no bindings from the package are required during
compilation, the package is not loaded at compile-time.  This is in
contrast to REQUIRE, which always loads the specified package, whether
or not its bindings are used.
** Native Interface
*** native c-string &optional result-class -> value [special]
Includes a snippet of C, with escaping back into Lisp, and automatic
conversion to and from native values.
