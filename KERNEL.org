* Kernel Language Draft
** Modules
*** defmodule name sig &rest typed-structure -> nil [special]
Defines a new named environment, that can be separately compiled.  The
body of a module cannot access lexically enclosing variables.  The
binding for the module exists in the variable namespace, but cannot
be changed.  The body of the module is an environment in which new
local bindings can be created.
*** signature &body [special]
*** structure &body [special]
*** open module -> nil [special]
Loads the specified module if it isn't loaded yet, and makes its
top-level bindings accessible in the current environment.
*** open-for-syntax module -> nil [special]
Loads the specified module before loading macros defined in the
current module.  This is useful for utility functions used by macros,
as macros have no access to runtime bindings.  If macros use other
macros, modules may be loaded more than once during compilation, in a
phase-separated tower.
** Bindings
*** defparameter name value -> name [special]
Defines a variable binding with the given name and value in the
current environment.  If the binding is already defined, its value is
updated.
*** defun name sig body -> name [special]
Defines a function binding with the given name and function in the
current environment.  If the binding is already defined, its value is
updated.
*** setq name value -> value [special]
Sets the global or local variable binding with the given name to the
given value.  Signals an error if no such binding is defined.
*** fsetq name function -> function [special]
Sets the global or local function binding with the given name to the
given function.  Signals an error if no such binding is defined.
*** boundp symbol -> boolean [function]
Returns true if there is a variable binding with the given name in the
current environment.
*** fboundp symbol -> boolean [function]
Returns true if there is a function binding with the given name in the
current environment.
** Functions
*** lambda signature &body -> function [special]
Creates an anonymous function.  The body of a lambda is an environment
in which new local bindings can be defined.
*** apply function (args <list>) (keys <dict>) -> result* [function]
Applies a function to the given positional and keyword arguments.
*** funcall function &rest args &keys keys -> result* [function]
Applies a function to the given positional and keyword arguments.
*** function name -> function [special]
Returns the function of the global or local function binding with the
given name.
** Multiple Values
*** values &rest objects -> object* [special]
Returns multiple values.  
*** multiple-value-call function &rest forms -> result* [special]
Calls a function with multiple values.
** Control Flow
*** if test-form then-form else-form -> value* [special]
If the test form evaluates to true, evaluates the then form, otherwise
evaluates the else form.
*** progn &rest exprs -> value* [special]
Evaluates the expressions in sequence and returns the value of the
last.  If a PROGN occurs at the top-level of an environment, its
contents are spliced into the top-level, as if the PROGN didn't exist.
This is useful for writing macros that expand to more than one
top-level definiton and/or expression.
*** unwind-protect protected-form &body cleanup-forms -> result* [function]
Evaluates the protected form and ensures that the cleanup forms are
evaluated whether the protected thunk returns normally, or via a
non-local jump.  Returns the values of the protected form.
*** block name &body forms -> result* [special]
Establishes a lexical binding for a nonlocal exit for a body of code.
Code may return from the block with RETURN-FROM.
*** return-from block-name &optional result -> | [special]
Performs a non-local jump to the given block.
*** tagbody &body tagbody -> nil [special]
Creates a body of expressions and tags.  Expressions in the TAGBODY
may perform non-local jumps to tags with GO.
*** go tag -> | [special]
Performs a non-local jump to the given tag.
** Classes
*** defclass name &optional superclasses slot-specifiers class-options -> name [special]
Creates a new class (or updates an existing class) with the given
name, superclasses, and slot specifiers.
*** definstance class super [special]
Dynamically adds a "mixin" superclass to a class.
*** subclassp a b -> boolean [function]
Returns true if class A is a subclass of class B.
** Objects
*** make class &keys slots -> object [function]
Creates a new object of the given class, and initializes its slots
using the supplied dictionary.
*** class-of object -> class [function]
Returns the class of the given object.
*** the class object -> object [special]
Casts the object to the specified class.  Signals an error if object
is not a generalized instance of the class.
** Generic Functions
*** defgeneric name sig [special]
** Methods
*** defmethod name sig body -> nil [special]
Sets the method definition with the given name for the class.
*** find-method object method-name &rest &keys -> function [function]
Looks for the method with the given name in the object's class and
superclasses.
*** call-next-method &rest args -> result* [local function]
Calls the next method, aka "super".  Only available inside methods.
*** no-next-method object method-name args keys -> result* [generic]
Called when there's no next method.  To handle this, define a method
on this generic method for your class.
*** no-applicable-method object method-name args keys -> result* [generic]
Called when no method with the given name exists in the object's class
or its superclasses.  To handle this, define a method on this generic
function for your class.
** Slots
*** slot-value object slot-name -> value [function]
Returns the value of the named slot of the object.
*** set-slot-value object slot-name value -> value [function]
Sets the named slot of the object to the given value.
*** slot-boundp object slot-name -> boolean [function]
** Dynamic Variables
*** defdynamic name value -> name [function]
Creates a new dynamic (thread-local) variable object.
*** dynamic name -> value [function]
Returns the value of the dynamic variable.
*** set-dynamic name value -> value [function]
Sets the value of the dynamic variable.
** Macros
*** defsyntax name expander-function -> name [special]
Defines an expander function with the given name in the current
environment.
*** quasisyntax form -> form [special]
Constructs a piece of quoted syntax with unquotes.
*** datum->syntax template-id form -> form [function]
Repaints the form with the same color as the template identifier.
** Evaluation
*** eval form -> result* [special]
Evaluates the form in the top-level environment and returns its value.
** Native Interface
*** native c-string &optional result-class -> value [special]
Includes a snippet of C, with escaping back into Lisp, and automatic
conversion to and from native values.
