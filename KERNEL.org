* Kernel Language Draft
** Bindings
*** defparameter name value -> name [special]
Defines a variable binding with the given name and value in the
current environment.
*** defun name function -> name [special]
Defines a function binding with the given name and function in the
current environment.
*** setq name value -> value [special]
Sets the global or local variable binding with the given name to the
given value.
*** fsetq name function -> function [special]
Sets the global or local function binding with the given name to the
given function.
*** boundp symbol -> boolean [function]
Returns true if there is a variable binding with the given name in the
current environment.
*** fboundp symbol -> boolean [function]
Returns true if there is a function binding with the given name in the
current environment.
** Functions
*** lambda signature &body -> function [special]
Creates an anonymous function.  The body of a lambda is an environment
in which new local bindings can be defined.
*** apply function (args <list>) (keys <dict>) -> result [function]
Applies a function to the given positional and keyword arguments.
*** funcall function &rest args &keys keys -> result [function]
Applies a function to the given positional and keyword arguments.
*** function name -> function [special]
Returns the function of the global or local function binding with the
given name.
*** values &rest objects -> object* [special]
Returns multiple values.  
*** multiple-value-call function &rest forms -> result [special]
Calls a function with multiple values.
** Control Flow
*** if test-form then-form else-form -> value [special]
If the test form evaluates to true, evaluates the then form, otherwise
evaluates the else form.
*** progn &rest exprs -> value [special]
Evaluates the expressions in sequence and returns the value of the
last.  If a PROGN occurs at the top-level of an environment, its
contents are spliced into the top-level, as if the PROGN didn't exist.
This is useful for writing macros that expand to more than one
top-level definiton and/or expression.
*** call-with-escape-continuation function -> result [function]
Calls the given function with one argument, a function that represents
the current continuation.  Calling the continuation function with a
value will abort the current computation, and return the value from
the original call to CALL-WITH-ESCAPE-CONTINUATION.  An error is
signaled if the continuation is called more than once, or after the
dynamic extent of CALL-WITH-ESCAPE-CONTINUATION has ended.
*** unwind-protect protected-thunk cleanup-thunk -> result [function]
Calls the protected thunk and ensures that the cleanup thunk is called
whether the protected thunk returns normally, or via a non-local exit.
*** tagbody &body tagbody -> nil [special]
Creates a body of expressions and tags.  Expressions in the TAGBODY
may perform non-local jumps to tags with GO.
*** go tag -> | [special]
Performs a non-local jump to the given tag.
** Dynamic Variables
*** make-dynamic value -> dynamic [function]
Creates a new dynamic (thread-local) variable object.
*** dynamic dynamic -> value [function]
Returns the value of the dynamic variable.
*** set-dynamic dynamic value -> value [function]
Sets the value of the dynamic variable.
** Macros
*** defsyntax name expander-function -> name [special]
Defines an expander function with the given name in the current
environment.
*** quasisyntax form -> form [special]
Constructs a piece of quoted syntax with unquotes.
*** datum->syntax template-id form -> form [function]
Repaints the form with the same color as the template identifier.
** Evaluation
*** eval form -> result [special]
Evaluates the form in the top-level environment and returns its value.
** Classes
*** make-class name superclasses slot-specifiers -> class [function]
Creates a new class with the given name, superclasses, and slot
specifiers.
*** set-superclasses class superclasses [function]
Updates the superclasses of the class.
*** put-method class method-name function [function]
Sets the method definition with the given name for the class.
*** set-slot-specifiers class slot-specifiers [function]
Updates the slot specifiers of the given class.  Instances are updated
lazily to the new layout.
*** subclassp a b -> boolean [function]
Returns true if class A is a subclass of class B.
** Objects
*** make-instance class &keys slots -> object [function]
Creates a new object of the given class, and initializes its slots
using the supplied dictionary.
*** find-method object method-name &rest &keys -> function [function]
Looks for the method with the given name in the object's class and
superclasses.
*** slot-value object slot-name -> value [function]
Returns the value of the named slot of the object.
*** set-slot-value object slot-name value -> value [function]
Sets the named slot of the object to the given value.
*** class-of object -> class [function]
Returns the class of the given object.
*** call-next-method &rest args -> result [local function]
Calls the next method, aka "super".  Only available inside methods.
*** no-next-method object method-name args keys -> result [generic]
Called when there's no next method.  To handle this, define a method
on this generic method for your class.
*** no-applicable-method object method-name args keys -> result [generic]
Called when no method with the given name exists in the object's class
or its superclasses.  To handle this, define a method on this generic
function for your class.
** Packages
*** defpackage name exports &body -> nil [special]
Defines a new named environment, that can be separately compiled.  The
body of a package cannot access lexically enclosing variables.  The
binding for the package exists in the variable namespace, but cannot
be changed.  The body of the package is an environment in which new
local bindings can be created.
*** require package -> nil [special]
Loads the specified package if it isn't loaded yet, and makes its
top-level bindings accessible in the current environment.
*** require-for-syntax package -> nil [special]
Loads the specified package before loading macros defined in the
current package.  This is useful for utility functions used by macros,
as macros have no access to runtime bindings.  If macros use other
macros, packages may be loaded more than once during compilation, in a
phase-separated tower.
** Native Interface
*** native c-string &optional result-class -> value [special]
Includes a snippet of C, with escaping back into Lisp, and automatic
conversion to and from native values.
